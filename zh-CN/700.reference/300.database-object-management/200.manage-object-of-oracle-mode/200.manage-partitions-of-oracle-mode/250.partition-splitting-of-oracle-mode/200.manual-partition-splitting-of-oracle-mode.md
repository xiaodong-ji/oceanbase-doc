|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type|Oracle Mode|

# 手动分区分裂

OceanBase 数据库支持在分区表中手动进行分区分裂操作，即将一个已有的分区拆分为多个分区。这个功能可以指定需要分裂的分区和新分区的分裂位点进行手动执行分区分裂命令，根据需求和数据增长情况对分区进行调整。

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>当前版本分区分裂功能为实验特性，暂不建议在生产环境使用。</p>
</main>

## 手动分区分裂操作的支持情况

当前版本仅支持对 Range 分区的一级分区表进行手动分区分裂操作。

## 使用限制及注意事项

* 不支持手动分裂 List、Hash 分区表。
* 不支持手动分裂二级分区表。
* 不支持被手动分裂的表的分区键与主键前缀不一样。
* 不支持无主键表的手动分区分裂。
* 不支持列存表的手动分区分裂。
* 如果表所在的 `TABLEGROUP`（表组）里面包含了多张表时，不支持手动分区分裂；如果这个 `TABLEGROUP` 中只有这张表，则支持手动分区分裂。
* 不支持物化视图的手动分区分裂。
* 不支持全局索引的手动分裂。
* 不支持 GIS 索引的手动分裂。
* 不支持向量索引的手动分区分裂。
* 不支持单独分裂局部索引、LOB 表的分区。

## 手动分区分裂语法

```sql
ALTER TABLE table_name SPLIT PARTITION partition_name split_partition_option;

split_partition_option:
    split_at_format
    | split_into_format

split_at_format:
    AT (value) [INTO (PARTITION [split_partition_name], PARTITION [split_partition_name])]

split_into_format:
    INTO (PARTITION split_partition_name VALUES LESS THAN (value)
          [, PARTITION split_partition_name VALUES LESS THAN (value) ...]
           , PARTITION split_partition_name)
```

### 参数解释

|       **参数**       | **说明** |
|----------------------|----------|
| table_name           | 指定表名。|
| partition_name       | 指定待分裂的分区名称。|
| split_at_format      | 使用此语法分区分裂时，将会以给定的 `value` 为界限，将源分区分裂为两个分区。也可以使用 `INTO` 子句给分裂出的分区设置名称。|
| value                | 指定分区分裂的界限（取值范围）。|
| split_partition_name | 指定分裂出的新分区名称。|
| split_into_format    | 使用此语法分区分裂时，可以将一个分区分裂为多个分区，分区分裂所定义的 `value` 范围需要保证与源分区的 `value` 范围相同，且需要保证按升序定义 `value`（不允许填写最后一个分区分裂的定义，其 `value` 等同于源分区）。|

## 示例

创建 Range 分区的一级分区表 `test_tbl1`。

```sql
CREATE TABLE test_tbl1(col1 INT, col2 INT, PRIMARY KEY(col1))
    PARTITION BY RANGE(col1)
    (PARTITION p0 VALUES LESS THAN(100),
     PARTITION p1 VALUES LESS THAN(200),
     PARTITION p2 VALUES LESS THAN(300),
     PARTITION p_max VALUES LESS THAN (MAXVALUE));
```

* 把 `test_tbl1` 表的分区 `p0` 分裂成两个新的分区，分裂的位置是在 `50` 这个值所对应的行上。分裂后，原来的分区 `p0` 被分成两个新的分区，新分区名称由系统分配。

    ```sql
    ALTER TABLE test_tbl1 SPLIT PARTITION p0 AT (50);
    ```

* 把 `test_tbl1` 表的分区 `p1` 分裂成两个新的分区，分裂的位置是在 `150` 这个值所对应的行上。分裂后，原来的分区 `p1` 被分成两个新的分区，一个新分区名称为 `p1_1`，另一个新分区名称由系统分配。

    ```sql
    ALTER TABLE test_tbl1
        SPLIT PARTITION p1 AT (150) INTO ( 
            PARTITION p1_1, 
            PARTITION);
    ```

* 把 `test_tbl1` 表的分区 `p2` 分裂成两个新的分区，分裂的位置是在 `250` 这个值所对应的行上。分裂后，原来的分区 `p2` 被分成两个新的分区 `p2_1` 和 `p2_2`。

    ```sql
    ALTER TABLE test_tbl1
        SPLIT PARTITION p2 AT (250) INTO (
            PARTITION p2_1,
            PARTITION p2_2);
    ```

* 把 `test_tbl1` 表的分区 `p_max` 分裂成三个新的分区，分裂的位置是在 `400` 和 `500` 这两个值所对应的行上。分裂后，原来的分区 `p_max` 被分成三个新的分区 `p_max_1`、`p_max_2` 和 `p_max_3`。

    ```sql
    ALTER TABLE test_tbl1
        SPLIT PARTITION p_max INTO (
            PARTITION p_max_1 VALUES LESS THAN (400),
            PARTITION p_max_2 VALUES LESS THAN (500),
            PARTITION p_max_3);
    ```

* 查看表 `test_tbl1` 的结构和定义。

    ```sql
    SHOW CREATE TABLE test_tbl1;
    ```

    返回结果如下：

    ```shell
    +-----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | TABLE     | CREATE TABLE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
    +-----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | TEST_TBL1 | CREATE TABLE "TEST_TBL1" (
    "COL1" NUMBER(*,0),
    "COL2" NUMBER(*,0),
    PRIMARY KEY ("COL1")
    ) COMPRESS FOR ARCHIVE REPLICA_NUM = 1 BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0
    partition by range(col1) size ('128MB')
    (partition "P8195" values less than (50),
    partition "P8196" values less than (100),
    partition "P1_1" values less than (150),
    partition "P8197" values less than (200),
    partition "P2_1" values less than (250),
    partition "P2_2" values less than (300),
    partition "P_MAX_1" values less than (400),
    partition "P_MAX_2" values less than (500),
    partition "P_MAX_3" values less than (MAXVALUE)) |
    +-----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    1 row in set
    ```

## 相关文档

[ALTER TABLE](../../../../500.sql-reference/100.sql-syntax/300.common-tenant-of-oracle-mode/900.sql-statement-of-oracle-mode/100.ddl-of-oracle-mode/1000.alter-table-of-oracle-mode.md)
